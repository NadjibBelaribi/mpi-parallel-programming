Ce projet utilise les Modèles Numériques de Terrain (ou MNT, https://fr.wikipedia.org/wiki/Mod%C3%A8le_num%C3%A9rique_de_terrain), qui sont simplement des cartes d'altitude d'une région. Elles sont stockées dans des fichiers <*.mnt> de format très simple, en texte clair : quelques caractéristiques (taille, position sur terre, etc.) suivies d'un tableau de nombres flottants donnant l'altitude de chaque point. Quelques exemples, de différentes tailles, se trouvent dans l'archive ci-jointe.

Le code ci-joint (http://gauvain.u-strasbg.fr/~loechner/ens/parall/MPI/tp/MNT.tar.gz) consiste à calculer le remplissage des cuvettes de la carte par l'algorithme de Darboux. Le programme fourni enregistre une carte modifiée (cuvettes remplies) dans le fichier passé en troisième argument, ou sur la sortie standard sinon. Il affiche également sur la sortie standard une carte des cuvettes remplies. La boucle while principale (darboux.c, dernière fonction) calcule itérativement une nouvelle carte W à partir d'une carte existante Wprec, et s'arrête dès que W et Wprec sont identiques. Cette boucle est intrinsèquement séquentielle : W dépend de Wprec à chaque itération. Le calcul de W utilise en chaque point [i,j] les valeurs des 8 voisins de [i,j] dans Wprec : W[i,j] = f(Wprec[i +/- 1, j +/- 1]).

Ce projet consiste à paralléliser l'algorithme de Darboux en MPI (et OpenMP pour l'optimisation). La seule fonction à paralléliser est la dernière fonction du fichier darboux.c. Voici quelques indications :
1. vous découperez les matrices Wprec et W en bandes de taille égale, ou similaires : la hauteur de la matrice (nrows) n'est pas forcément divisible par le nombre de processus ;
2. au début de chaque itération, vous enverrez les première et/ou dernière ligne de Wprec au processus précédent/suivant (et les recevrez de manière symétrique), car ces processus auront besoin de ces valeurs pour calculer les lignes de leurs bords ;
3. puis vient le calcul ;
4. enfin, pour vérifier si le calcul est terminé sur tous les processus, vous ferez une réduction sur la variable modif.

Une fois que ce programme parallèle simple fonctionne (il fonctionne s'il calcule exactement les mêmes résultats que le programme séquentiel), sauvegardez-le et effectuez des mesures de performance. Puis réfléchissez à son optimisation : les échanges des premières/dernières lignes peuvent être réalisés simultanément à une partie du calcul. De même, la réduction peut être réalisée simultanément au calcul de l'itération suivante, et l'arrêt de la boucle while s'effectuera une itération plus tard. Vous pouvez également utiliser OpenMP pour exécuter des boucles parallèles sur chaque processeur multi-coeurs et un seul processus par machine. Mesurez les gains de performances que vous obtenez grâce à ces optimisations. Comparez l'accélération dans le cas simple et dans le cas optimisé. Observez -vous de meilleures performances ?

Est-ce que l'efficacité est de 100% sur quelques machines d'un réseau distribué ?

Ce projet est à réaliser en binôme. Vous déposerez une archive (de préférence .tar.gz) contenant votre code et un petit rapport (format pdf) contenant les mesures que vous avez effectuées. N'oubliez pas d'indiquer les noms des deux participants au projet dans le rapport, et ne déposez qu'une seule archive par binôme. N'incluez pas les fichiers de données fournis, ils sont trop gros pour être déposés sur moodle.
